
===================
第一章：AWK简易教程
===================

:Author: Translated By Gotaly(gotaly@163.com)
:Version: 0.0.1
:Last Update:	2013.03.29


AWK 是一门适合处理多种计算和数据操作任务且操作方便、容易表达的程序语言。本章通过一个简易的教程让读者可以在最短的时间书写自己的AWK程序代码。第二章则详细描述了完整的AWK语言内容，后面的其他章节则展示了AWK在不同领域中解决问题的例子。我们挑选了有实际用处的、有趣的以及启发性的例子贯穿全书，帮助读者更好的理解AWK。

1.1 小试牛刀
============

通常有用的AWK仅仅是由一两行代码组成的简短程序。假设现在有个数据文件（emp.data）记录了你的员工的工作信息，其由姓名、每小时的工资以及对应的工作时间组成，每个员工的数据记录构成一行。如下所示::

	Beth	4.00	0 
	Dan 	3.75	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mary	5.50	22 
	Susie	4.25	18

假设现在你想得到工作时间大于0的员工应得的工资。那么可以尝试如下的AWK命令::


	awk '$3  >  0  {  print  $1,  $2  *  $3  }' emp.data 

程序运行后会得到如下的输出结果::

	Kathy	40 
	Mark	100 
	Mary	121 
	Susie	76.5 

该命令操作通过系统调用AWK程序，其AWK程序代码用单引号括起来部分，用文件 *emp.data* 内容作为源操作数据内容。单引号中包裹的就是AWK程序，它由一个 *pattern-action* 语句组成。其中的pattern： `$3  >  0` 表示匹配第三个字段值大于0的所有输入行，而action ： `{  print  $1,  $2  *  $3  }` 打印每个匹配行的第一个字段以及第二字段和第三字段的乘积。

如果想得到工作时间为0的员工的姓名，可以使用如下命令::

	awk  '$3  ==  0  {  print $1  }' emp.data 

这个命令中的pattern: `$3  ==  0` 匹配了第三个字段为0的所有输入行，而action: `{  print $1  }` 则表示将匹配输入行的第一个字段打印出来。

在阅读本书的时候，请尝试着修改我们给出的实例程序，它们一般都很短，通过修改可以从中了解AWK是怎样工作的。在类Unix系统上，上述示例可能如下所示::

	$  awk  '$3  >  0  {  print  $1,  $2  *  $3  }' emp.data 
	Kathy  40 
	Mark 100 
	Mary 121 
	Susie  76.5 
	$  awk  '$3  ==  0  {  print  $1  }' emp.data 
	Beth 
	Dan 
	$ 

“$”是系统的提示字符，不同的类Unix可能不同。

AWK程序的结构
-------------

在上面的示例中，单引号中包裹的就是AWK程序。如引号中示例，本章中的AWK程序都是由一个或多个 pattern-action 语句罗列而成的::

	pattern  {  action  } 
	pattern  {  action  } 

AWK基本的操作就是从输入流中依次读入每个输入行，然后搜索匹配pattern的行。这里匹配精确定义需要结合pattern的内容，比如 `$3 > 0` 就意味着“该条件为真”

其完整的执行流程是这样的：读入一个输入行，轮流着测试每个pattern，如果匹配那么执行该pattern后面的action。然后再读入下一个输入行，重复该过程，直到读完所有的输入。

上面的示例程序就是典型的 pattern-action 语句::

	$3  ==  0  {  print  $1  } 

该语句是一个单个的pattern-action语句。打印第三个字段为0的那一行的第一个字段。

在pattern-action语句中，既可以省略pattern也可以省略action。比如省略action时::

	$3  ==  0 

将会打印所有匹配该pattern的输入行的内容（这里的匹配就是该条件为真）。这句程序会打印源数据文件emp.data中第三个字段为0的两行::

	Beth	4.00	0 
	Dan 	3.75	0

如果省略pattern时::

	{  print  $1  } 

该action会打印每一行第一个字段，即如果pattern省略了，那么action作用于每一个输入行。

由于pattern和action都可以省略，所以将action用花括号括起来，以示区别。 


运行一个AWK程序
---------------

运行一个AWK程序的方式有多种。可以在命令行上使用这样的格式::

	awk 'program' input files

将会在所有的输入文件上执行 program 的AWK程序，如::

	awk  '$3  ==  0  {  print  $1  }' file1  file2 

将会打印file1 和 file2中所有第三个字段为0的行的第一个字段。

如果省略input files，如::

	awk 'program'

那么AWK会从标准输入中获得输入数据，也就是你在终端中输入的所有内容会传递给AWK,直到遇到了EOF（Unix上市Ctrl+D，Windows上市Ctrl+Z），在类Unix上可能看起来如下所示::

	$  awk  '$3  ==  0  {  print  $1 }'
	Beth  4.00  0 
	Beth 
	Dan  3.75  0 
	Dan 
	Kathy  3.75  10 
	Kathy  3.75  0 
	Kathy 
	...

重复出现的姓名是由系统打印出来的。

这种运行模式使得体验AWK变得更容易：先输入AWK程序，然后在输入数据，接着观察结果。这里，我们再次建议读者去尝试这些例子并做修改。

注意上述的执行方式中，AWK程序被单引号括住。这种方式保护了AWK程序中的某些字符如$不被Shell解释同时也是的AWK程序可以延续到多行。

上述方式对于AWK程序比较短时是非常方便的，但是如果AWK程序比较长的话，那么将其单独放到一个文件中（如 profile），并用如下命令会更方便::
	
	awk  -f progfile  optional  list  of input files 

“-f”选项使得AWK从所给文件中取得程序内容，这里用文件profile表示放有AWK程序的文件的文件名。

错误
-----

如果你的AWK程序中出错了，AWK会给你一个很明显的提示。比如当你输错了一个花括号时，如下面所示的::

	awk  '$3  ==  0  [  print  $1  }' emp.data

AWK将会提示::
	
	awk:  syntax error  at source  line  1 
	 context  is 
			$3  ==  0  >>>  [  <<< 
			extra  } 
			missing 
	awk:  bailing out  at source line  1 

"Syntax  error" 表示AWK检测到在符号 “>>> <<<”之间代码出现了一个语法错误。
"Bailing  out"  表示没有做恢复 操作，即程序停止退出了。有的时候AWK会给
出更多的关于出错的信息，如遗漏了花括号或者圆括号。

上例中由于遇到了语法错误，AWK停止继续执行程序。然后有的错误不是在执行前发现而是在程序执行过程中出现。比如除零错误，此时AWK会停止执行程序并报告收入行的行号以及程序中出现除零逻辑的程序代码行号。

1.2 简单输出
============

为了便于说明，本章后续的内容中出现的简短而有代表意义的AWK程序都是操作上述提到的文件 *emp.data* 的。我们将详细介绍程序是如何执行的，通过这些例子主要是介绍
通过AWK来做打印字段、选择输入以及转换数据是轻而易举的事情。这里我们没有展示所有AWK可以做的，也没有介绍详细的介绍这里所列的每一个示例。但是在读完本章后，读者可以自己完成一些简单的程序，并为后续章节的阅读打下基础。

在后面的示例中，我们仅给出AWK程序而不是整个的命令行输入。该程序既可以如之前的例子在命令行上用单引号括起来作为awk命令的第一个参数，也可以将其放在一个单独的脚本文件中，然后用“-f”选项指定AWK脚本文件。

在AWK中精油两种数据类型：数字和由字符组成的字符串。文件 *emp.data* 就是由这两种类型的数据组成的-- 混合了由制表符和空格分隔的数字和字符串。

AWK 读入一个输入行，然后将每一行数据分隔成各个字段，默认情况下，字段是有非制表符和空格组成的（译者注：也就是按空格或者制表符进行分隔）。当前行上的第一个字段被称作$1,第二个字段被称作$2以此类推。而正行的内容用$0来表示。字段的总数是每行可以个不相同的。

通常情况下，我们所需要完成的工作就是打印部分字段或者在某些字段上进行一些计算。本章中讨论的例子大多是这样的。

打印每一行
----------

如果一个action没有pattern，该aciton会作用在每一个输入行之上，如果再action中仅有 *print* 命令自身，那么它会打印当前行所有内容。因此程序::

	{  print  } 

打印所有的输入到标准输出，由于$0同样表示整行内容，因此程序::

	{ print $0 }

会做同样的事情。

打印指定的字段
--------------

使用单一的 *print* 语句可以打印一个输入行上的多个字段，下面的程序段会打印每一个输入行的第一和第三个字段::

	{  print $1,  $3  } 

将该程序用于 *emp.data* 文件上会产生输出::

	Beth 0 
	Dan  0 
	Kathy  10 
	Mark 20 
	Mary 22 
	Susie  18 

在print语句中，被逗号分隔部分，默认情况下输出时会被一个空格分开，当打印完一行上的内容后会再打印出一个换行符。可以通过配置来修改该行为，我们会在第二章讨论该内容。

NF：字段数目
------------

通常情况下，使用$1、$2等来指定某个字段，然后可以在$跟任何表达式来表示某个字段，此时AWK会计算$后面表达式的值，然后用该值表示的数字来指代第几个字段。AWK会统计输入行中有多少个字段，并将该值放在内建变量NF中，因此程序段::

	{  print NF,  $1,  $NF  }

会打印字段的总数以及第一个和最后一个字段的内容。

计算和输出
----------

AWK还可以再字段值上做计算操作并将其结果包含在输出结果中，如程序段::

	{  print  $1,  $2  *  $3  } 
	
会打印出每位员工的姓名和其对应的总工资数目。输出为::

	Beth 0 
	Dan  0 
	Kathy  40 
	Mark  100 
	Mary  121 
	Susie  76.5 

后面我们还会介绍如何让输出更好看一点。

打印行号
--------

AWK还提供了另一个内建变量NR,它统计了到目前为止读入的行数。我们可以用NR和$0为emp.data的内容开始出加上行号::

	{  print NR,  $0  } 

输出结果为::

	1  Beth 	4.00	0 
	2  Dan  	3.75	0 
	3  Kathy	4.00	10 
	4  Mark 	5.00	20 
	5  Mary 	5.50	22 
	6  Susie	4.25	18 

指定输出文本
------------

我们还可以再字段中间穿插给定的文本内容同时对字段内容进行计算，如::

	{  print  "total  pay  for",  $1,  "is",  $2  *  $3  } 

会打印结果::

	total  pay  for  Beth is 0 
	total  pay  for  Dan is 0 
	total  pay  for  Kathy  is 40 
	total  pay  for  Mark is 100 
	total  pay  for  Mary  is 121 
	total  pay  for  Susie  is 76.5 

在print语句中，被双引号包裹的内容会和字段以及字段值计算的结果一样被输出。

1.3 自定义输出
==============

print语句主要用于快速和简单的输出情况下，如果想自定义输出格式，那么可以使用printf语句。如同我们将在 *2.4节* 中见到的printf几乎可以输出任何格式的内容，但是在本章中我们仅介绍其的一部分能力。

罗列字段
--------

printf语句的格式为::

	printf  (format,  value_1,  value_2,  •••  ,  value_n) 

其中format是一个包含逐字输出和表示怎么输出值的规则得字符串。输出规则是由一个“%”和紧随其后的控制输出值格式的字符。第一个规则指示了value_1的输出格式，第二个规则指示了value_2的输出格式以此类推。因此“%”开头的规则的数目要有后面的值的数目一样多。

这里的一个示例展示了用printf输出每个员工的总工资::

	{  printf("total  pay  for  %s  is $%.2f\n",  $1,  $2  *  $3)  } 

printf语句中的规则字符串包含两个“%”开头的规则。第一个“%s”表示将第一个值 “$1”作为一个由字符组成的字符串输出；第二个“%.2f”表示将第二个值“$2*$3”的计算结果当作一个小数点后面有两位有效位的浮点数输出。其他剩余的字符（包括美元符号）则原封不动的输出，最后的“\n”表示一个换行符，它会使得后续的输出从一个新行开始。将该程序段作用在 *emp.data* 会得到输出::

	total  pay  for  Beth is $0.00 
	total  pay  for  Dan is $0.00 
	total  pay  for  Kathy  is $40.00 
	total  pay  for  Mark  is $100.00 
	total  pay  for  Mary  is $121.00 
	total  pay  for  Susie  is $76.50 

当使用printf语句时，不会自动输出空格或者换行，必需手动指定。

下面是另个输出每个员工的姓名和总工资的程序段::

	{  printf("%-8s  $%6.2f\n", $1,  $2  *  $3)  } 

第一个规则“%-8s”，打印出一个由字符组成的8个字符宽度的字符串。第二个规则“%6.2f”将计算得到的总工资作为一个小数点后面哟两位有效位的占据6个字符宽度的浮点数输出::
	
	Beth	$  0.00 
	Dan 	$  0.00 	
	Kathy	$  40.00   
	Mark 	$100.00
	Mary 	$121.00
	Susie 	$  76.50

后面我们会介绍更多的printf的例子；printf完整的介绍见 2.4节。 

对输出进行排序
--------------

现在假设你想打印所有员工的信息以及其工资，并想将结果按照总工资递增输出。最简单的方式就是用AWK输出 *员工姓名-工资* 的记录，然后用一个排序程序对其进行排序。在类Unix系统上用下面的命令行程序::

	awk  '{  printf("%6.2f  %s\n", $2  *  $3,  $0)  }' emp.data  sort 

将AWK的输出通过管道传递给 *sort* 程序，产生的结果如下::

	  0.00  Beth	4.00  0 
	  0.00  Dan 	3.75  0 
	 40.00  Kathy	4.00  10 
	 76.50  Susie	4.25  18 
	100.00  Mark	5.00  20 
	121.00  Mary	5.50  22 

1.4 选择
============

通过AWK的pattern可以很好的从输入中选择需要的部分然后进行进一步的处理。由于pattern后面不接任何action时会打印整个行，因此很多AWK程序仅包含一个pattern。本节将演示一些有用的pattern。

通过比较来选择
--------------

下面的示例通过一个比较pattern选择出员工工资大于或则等于$5.00每个小时的员工，
也就是输入行中第二个字段的值大于或者等于5::

	$2  >=  5 

它将选择emp.data中结果::

	Mark	5.00 	20 
	Mary	5.50 	22
 
通过计算选择
------------

程序段::

	$2  *  $3  >  50  {  printf("$%.2f for  %s\n", $2  *  $3,  $1)  } 

会打印出总工资额大于 $50的员工信息::

	$100.00  for  Mark 
	$121.00  for  Mary 
	$76.50  for  Susie 

通过文本内容选择
----------------

除了使用数字测试，还可以选择输入行中包含指定单词或者语法的内容，下面的程序段会打印第一个字段为“Susie”的行::

	$1  ==  "Susie" 

操作符 “==” 用来测试是否相等。还可以通过正则表达式来选择包含特定的字符、单词或者语法等。下面的程序段会打印任何包含“Susie”的输入行的内容::

	/Susie/ 

输出为::

	Susie  4.25  18 

正则表达式可以用来指定更详细的pattern，完整的叙述参见第2.1节。

Patterns 的组合
---------------

patterns可以通过圆括号、表示“与或非”逻辑操作符“ &&、||和！”。程序段::

	$2  >=  4  ||  $3  >=  20 

将会打印出$2大于或者等于4或者 $3大于或者等于20的输入行::

	Beth	4.00  0 
	Kathy	4.00  10 
	Mark	5.00  20 
	Mary	5.50  22 
	Susie	4.25  18 

如果上述两个条件都匹配的行只会被输出一次。与之对比的可以看看下面的程序，它表示了两个pattern::

	$2  >=  4 
	$3  >=  20 

该程序段会将同时符合这两个条件的行输出两次::

	Beth	4.00  0 
	Kathy	4.00  10 
	Mark	5.00  20 
	Mark	5.00  20 
	Mary	5.50  22 
	Mary	5.50  22 
	Susie	4.25  18 

然而程序段::

	I  (  $2  <  4  &.&.  $3  <  20) 

会打印当 $2小于4同时$3小于20不成立时的输入行。该程序段的作用上上面的一样，只是可读性更差一点。	

数据验证
--------

真实的数据中往往是有错误的，AWK是一个优秀的测试数据是否合理以及格式是否合理的工具，这个过程一般叫做数据验证。

数据验证本质上来说是一种抑制功能：不是打印符合AWK规则的行而是打印符合逻辑的行内容。下面的程序段通过对比pattern在每一个输入行上执行五次判断::

	NF  I=  3  {  print  $0,  "number of fields  is not  equal  to  3"  } 
	$2  <  3.35 {  print  SO,  "rate  is below  minimum wage" } 
	$2  >  10  {  print  $0,  "rate  exceeds  $10  per  hour"  } 
	$3  <  0  {  print $0,  "negative  hours  worked" } 
	$3  >  60  {  print  $0,  "too many hours  worked" } 

如果源数据没有错误，则不会输出任何内容。

BEGIN 和 END
------------

特殊的pattern“BEGIN”匹配在开始读入第一行之前的情况,“END”匹配最后一行读入之后，下面的程序通过BEGIN打印一个表头::

	BEGIN 	{  print  "NAME RATE  HOURS";  print  ""  } 
			{  print  } 

输出为::

	NAME	RATE 	HOURS 
	Beth	4.00 	0 
	Dan 	3.75 	0
	Kathy	4.00  	10
	Mark	5.00  	20
	Mary	5.50 	22
	Susie 	4.25	18

通过用分号分隔，可以在一行中放多个语句。这里注意了 语句 `print \"\"` 表示打印一个空行，与表达式 `print` 是不一样的，后者会打印整行的内容。

1.5 用AWK做计算
===============

一个aciton是有多个被换行或者分号分隔的语句组成的。在前面的文章中，我们已经看到了仅有一个 `print` 语句组成的action。这一节提供了关于数字和字符串计算的示例。在这些语句中，不仅可以使用AWK内建的变量如NF，还可以使用自己定义的变量来做计算、排序等相关工作。在AWK中，用户自定的变量时不需要声明的。

计数
----

下面这个程序段用一个名叫 `emp` 的变量统计了工作超过15个小时的员工数目::

	$3  >  15  {  emp  =  emp  +  1  } 
	END  {  print emp,  "employees  worked  more  than  15  hours"  } 

当遇到第三个字段大于15的时候，变量emp的值增加一。当作用在文件 *emp.data* 上时产生输出为::

	3  employees  worked  more than  15  hours 

在AWK中数字变量初始化为0，因此这里不用显示的初始化变量emp。

求和和平均数
------------

为了计算有多少员工可以通过内建变量NR来得到，NR变量记录了到目前为止总共读入了多少行；在输入结束时其值就是总共的行数。
::
	
	END  {  print NR,  "employees"  } 

输出为::

	6  employees 

这里在给出一个程序通过内建变量NR来计算平均工资::

		{  pay  =  pay  +  $2  *  $3  } 
	END  {  print NR,  "employees" 
			print  "total  pay  is",  pay 
			print  "average pay  is",  pay/NR 
		}

第一个action计算了所有人的总工资，END匹配的action则打印出结果::

	6  employees 
	total  pay  is 337.5 
	average  pay  is 56.25 

通过printf我们得到了整齐的输出。如果仔细分析，该程序还存在一定的潜在错误，如果NR的值为0的话，那么AWK会尝试这除零，这样就会产生一个出错信息。

处理文本
--------

AWK的一个强项就是他处理由字符组成的字符串能够像其他语言处理数字一样的方便。AWK变量可以想放数字一样放字符串。下面这个程序找出小时工资最高的员工::

	$2  >  maxrate  {  maxrate  =  $2;  maxemp  =  $1  } 
	END  {  print  "highest  hourly rate:", maxrate, "for",  maxemp  } 

会打印::

	highest  hourly rate:  5.50 for  Mary 

在这段程序中用变量 *maxrate* 保存一个数字 ，*maxemp* 保存字符串。（如果小时工资最高的有多个数目相同的人，那么这段程序选取的是第一个找到的那个。）

字符串连接
----------

新字符串可以通过组合旧字符串得到，该过程称作字符串的连接，如下程序::

		{  names =  names $1  "  "  } 
	END  {  print names } 

该段程序通过将每个员工的名字和一个空格注意添加到变量 *names* 中 将从而将所有员工的姓名组合到一个字符串中，然后在END的action将结果输出出来::

	Beth Dan  Kathy  Mark  Mary Susie 

在AWK程序中通过一个接一个的书写字符串可以连接这些字符串（译者注:字符串中间用空格隔开）。对于每一个输入行，第一个语句连接了三个字符串：之前的变量 *names* 、第一个字段值以及一个空格，然后将连接后的结果赋值给变量 *names* 。因此在所有的输入行被读完后，变量 *names* 包含了一个由所有员工姓名跟随一个空格组成的长字符串。存放字符串的变量被系统初始化为null（即该变量中不含有任何字符），因此该段程序无需显示的初始化变量 *names* 。

打印最后一个输入行
-------------------

尽管变量NR在END的action中任保留了其值，但是此时$0却不保留最后一行内容了，因此程序::
	
		{  last  =  $0  } 
	END  {  print  last  } 

是一种打印最后一行的方法，输出为::

	Susie  4.25  18 

内建函数
--------

在上面我们看到了AWK维护了一些内建变量来维护一些常用的数据如字段数目和输入行数。类似的，AWK还提供了内建函数来计算其他有用的值。除了算术函数如平方根、对数、随机数等，还有些处理文本的的函数。其中一个常用的就是 *length* ，它用来计算一个字符串中字符的数目。下面这里个例子求出每个员工姓名中的字符数目::

	{  print  $1,  length($1)  } 

将产生如下结果::

	Beth 4 
	Dan  3 
	Kathy  5 
	Mark 4 
	Mary 4 
	Susie  5

统计行、单词以及字符
--------------------

下面这个程序使用length、 NF以及NR来计算输入流行数、单词数以及字符数 。为了方便起见，这里讲每个字段视为一个单词::

		{  nc  =  nc  +  length($0)  +  1 
			nw  =  nw  +  NF
		} 
	END { print NR,  "lines, ..  ,  nw,words,", nc, "characters"  } 

文件 *emp.data* 拥有::

	6  lines,  18  words, 77  characters 

在上面的程序中，我们为字符数多加了一个一，因为$0中并不包括换行符。

1.6 控制流语句
==============

AWK提供了一个 *if-else* 语句作为条件语句，还有其他几个循环语句，这些语句的模型都可以再C语言中找到。这些控制语句只可以在action中使用。

if-else 语句
------------

下面的程序段计算了所有工作时间超过6小时的员工的平均工资，它使用了一个 *if* 语句来避免除零错误::

	$2  >  6  {  n  =  n  +  1; pay  =  pay  +  $2  *  $3 }
	END  {  if  (n  >  0)  
				print n, "employees,  total  pay  is", pay, 
						 "average pay  is",  pay/n
			else 
				print  "no  employees  are  paid more than  $6/hour"
		}

作用于 *emp.data* 上的输出为::

	no  employees  are  paid more  than  $6/hour 

在 *if-else* 语句中，首先计算 *if* 后面的条件，如果结果为真那么第一个 *print* 被执行；否则第二个 *print* 语句被执行。注意到上面，可以通过逗号来分隔一个长语句，使得一条语句可以跨越多个行。

while 语句
----------

一个while语句包含一个条件和一个循环体。循环体中的语句在条件测试为真时会反复的执行。下面这个例子展示了一笔钱是怎么在一个固定的年增长率下慢慢增加的，其计算公式为 **value =  amount (I  +rate )^years** ::

	#  interest1  - compute compound  interest 
	#  input:  amount  rate  years 
	#  output:  compounded  value  at the  end  of each year 
	{
		i  =  1 
		while  (i  <=  $3)  { 
			printf("\t%.2£\n", $1  *  (1  +  $2)  " ^ i) 
			i  =  i  +  1 
		}
	}

循环条件在 *while* 后面的括号里，而循环体是在花括号里的两条语句。 `printf` 语句中的 “\t” 表示一个制表符，“^” 表示求幂， “#” 后面的是注释，注释会被AWK解释器忽略，但是可以帮助读程序的读者理解。

可以通过输入一个三个数字的组合来观察不同基数、利率和年数产生的结果。这里我们来看基数为 $1000在年利率分别为 6% 和12%的情况下五年的增长情况::

	$  awk -f  interest1 
		1000  .06  5 
			1060.00 
			1123.60 
			1191.02 
			1262.48 
			1338.23 
		1000  .12  5 
			1120.00 
			1254.40 
			1404.93 
			1573.52 
			1762.34 

for 语句
--------

另一个循环语句-- *for* 语句 将初始化、条件测试、循环变量的增长放在一行中。下面用 *for* 重写了前面的循环::

	#  interest2  - compute compound  interest 
	#  input:  amount  rate  years 
	#  output:  compounded  value  at the  end  of each year 
	
	{	for  (i  = 1;  i  <= $3;  i  = i  +  1) 
				printf("\t%.2f\n", $1  *  (1  +  $2)  ^ i) 
	}

初始化语句 `i = 1` 被执行一次，然后判断条件 `i <= $3`,如果结果为真，就执行 *printf* 语句，即执行循环体。执行完循环体后执行 `i = i + 1`。之后从循环测试开始下一次的循环。由于循环体只有一条语句，为了代码的紧凑，就没有为循环体增加花括号了。

1.7 数组
========

AWK提供了数组来存储一组相关的值。虽然数组是的AWK有更强的处理能力，但是这里我仅介绍一个简单的例子。下面的示例将输入倒叙输出。第一个action将每一行输入放入到一个名叫 *line* 的数组中；这样第一个数组元素就是 *line[1]* ,接着第二个数组元素就是 *line[2]* 以此类推。END的action用一个 *while* 语句将数组的元素从最后一个到第一个依次打印出来::

	#  reverse  - print  input  in reverse  order  by  line 
		{ line[$NR] =  $0  }  #  remember  each  input  line 
	END { i  = NR  #  print  lines  in reverse  order 
		while  (i  >  0)  { 
			print  line[i] 
			i = i  - 1
		}
	} 

作用在文件 *emp.data* 输出为::

	Susie	4.25	18 
	Mary 	5.50	22
	Mark 	5.00	20
	Kathy	4.00	10 
	Dan 	3.75	0 
	Beth 	4.00	0

这里再给出一个产生同样结果的使用 *for* 语句的程序段::

	#  reverse  - print  input  in reverse  order  by  line 
		{line[NR]  =  $0  }  #  remember  each  input  line 
	END  {for  (i  =  NR;  i  >  0; i  =  i  - 1) 
				print  line[i] 
	}

1.8 一些有用的单行代码
----------------------

尽管可以编写负责的AWK程序，但是确实有很多有用的程序不必我们到目前见到的程序复杂。这里收集了一些可以放在手边作为工具查阅的短程序。其中很多是我们见过的例子的变形。

1. 打印输入行的数目
	::

		END  {  print NR  }
2. 打印第十行
	::

		NR  ==  10
3. 打印每个输入文件的最后一行
	::

		{  print  $NF  } 
4. 打印最后一行的最后一个字段
	::

			{  field  =  $NF} 
		END  {  print  field  } 
5. 打印超过4个字段的每一行
	::

		NF  >  4 
6. 打印最后一个字段大于4的每一行
	::

		$NF >  4 
7. 打印所有输入文件总共包含的行数
	::

			{  nf :::  nf +  NF  }
		END  {  print nf } 
8. 打印包含 **Beth** 的行的数目
	::

			/Beth/  {  nlines  =  nlines  +  1  } 
		END  {  print nlines  } 
9. 打印最大的第一个字段，以及该行内容
	::

			$1  >  max {  max =  $1;  maxline  ~ $0 
		END  {  print max,  maxline  } 
10. 打印至少包含一个字段的行
	::

		NF  >  0 
11. 打印内容超过80个字符的行
	::

		length($0)  >  80 
12. 在行内容前增加行中包含字段的数目
	::

		{  print NF,  $0  } 
13. 依次打印第二个和第一个字段
	::

		{  print  $2,  $1  } 
14. 交互第一个和第二个字段，然后输出改行
	::

		{  temp  =  $1;  $1  ~ $2;  $2  =  temp;  print  } 
15. 将第一个字段替换成行号并打印改行
	::

		{  $1  =  NR;  print  } 
16. 将第二个字段删除后打印改行内容
	::

		{  $2  =  "";  print  } 
17. 反序打印每行中的各个字段
	::

		{ for  (i  =  NF;  i  >  0;  i  =  i  - 1)  printf("%s  " , $i) 
			printf  (  "\n" ) 
		}
18. 打印每行中字段的数目
	::

		{sum=  0 
		 for  (i  =  1;  i  <=  NF;  i  =  i  +  1)  sum  = sum +  $i 
		print sum
		} 
19. 统计输入中总共含有多少个字段
	::

			{  for  (i  =  1;  i  <=  NF;  i  =  i  +  1)  sum=  sum+  Si } 
		END  {  print sum  } 
20. 用字段的绝对值替换该字段然后输出改行内容 
	::

		{ for  (i  =  1;  i  <=  NF;  i  = i + 1)  if  ($i  <  0)  Si = -$i 
		  print
		} 


1.9 下一步学什么？
===================

至此，你已经看到了AWK基本的元素了。本章中的每一个程序都是由一系列 *pattern-action* 语句组成的。AWK 测试每一个输入行是否匹配pattern，如果匹配则执行与之相配的action。pattern可以包含数字和字符串的比较，action可以包含计算和格式输出。除了自动读入输入文件，AWK还将每一行输入分隔成多个字段。AWK提供了一些内建变量和函数，同时可以定义用户自己的比那里。通过组合使用这些机制可以形成一系列有用的用于计算短程序-- 许多其他语言中需要的内容在AWK中也可以见到。

本书剩余的部分将详细讨论每个细节。由于后面的例子可能比本章中见到的要长，我建议你尽快的书写自己的程序。通过书写可以让你更快的书写语言本身，这有助于你阅读后面更长的程序。另外实践是最好的答案。为了更好的学习，你应该流量本身中的例子，示例程序都包含了AWK语言的一些知识，比如怎样用一个特性或者怎样写出一个有意思的程序。

